# Copyright (c) DiGidot Technologies 2019# This file is under the MIT license# ------------------------------------------ Start of user parameters -------------------------------------------# Fill in the IP address of the C4set c4_url to "10.254.254.254"# Set broadcast_trigger from true to false if you  want to execute only on the C4 with the given IP address above. Else, Broadcast trigger to all C4's in the networkset broadcast_trigger to false# Set autoplay from false to true if you want to start the presentation right away when you're starting the applescriptset autoplay to false# ------------------------------------------ End of user parameters ------------------------------------------#try#	tell application "Finder" to set input to the (container of (path to me)) as text#end try#   display dialog input as string -- for testing purposes#return input# Globalsglobal c4_urlglobal destination_mac_addressglobal list_unique_idglobal list_scenenameglobal list_playlist_unique_idglobal list_playlist_name# set my_path to (((path to me as text) & "::") as alias) as string# log my_path# tell application "Finder" to get (container of (path to me)) as text# set theFile to "/tmp/scenelist.txt"# set str to readFile(theFile)set destination_mac_address to "00:00:00:00:00:00"if broadcast_trigger is true then set destination_mac_address to "FF:FF:FF:FF:FF:FF"set error_code to "0"set list_unique_id to {}set list_scenename to {}set list_playlist_unique_id to {}set list_playlist_name to {}# Program startlog "C4 Demo Application: Applescript HTTP-GET API from keynote v2.0"# First check if this is Applescript compatible firmwaremy checkFirmware()my getScenes()my getPlaylists()# Connect to the 'Keynote' applicationtell application "Keynote"		# Configure the auto play feature as well as checking if a document actually exists in 'Keynote'	if autoplay is true then activate	set current_slide to 0		if not (exists document 1) then error number -1		if autoplay is true then		try			if playing is false then start the front document		end try	end if		# Connect to the document which is openend in Keynote	tell the front document		repeat			# Check here if a next or previous slide is requested			if current_slide â‰  current slide then				set current_slide to current slide				tell current slide					if skipped is false then												# Check if there are any presenter notes (not regular notes!)						if presenter notes is not equal to "" then														# Grab all the text from the last '#'							set notes_array to my theSplit(presenter notes of it, "#")							set command to item 2 of notes_array														# Split again with '/' to get the main action and the name that applies to the action							set command_array to my theSplit(command, "/")														# Get the action (trigger, scene or playlist) and the name for the trigger, scene of playlist)							set action to item 1 of command_array							set parameter to item 2 of command_array														# Check if the paramter is a 'p' for playlist, 't' for trigger and 's' for sene							global final_url							set final_url to "0"							set argument_1 to 0							set command_array_size to count of command_array														if command_array_size is 3 then								set argument_1 to item 3 of command_array							end if														# Fire playlist based on name							if action is "p" then								set item_num to my list_position(parameter, list_playlist_name)																# Check if the given parameter is a valid playlist name								if item_num > -1 then									set parameter to item item_num of list_playlist_unique_id									set final_url to my StartPlaylist(parameter, 0)								else									log "Playlist not fired because not found: " & parameter								end if																# Fire scene based on name and an optional argument for the fade time in ms(ex: #s/testscene/1000							else if action is "s" then																set item_num to my list_position(parameter, list_scenename)																# Check if the given parameter is a valid scene name								if item_num > -1 then									set last_scene_name to parameter									set parameter to item item_num of list_unique_id									set final_url to my PlayScene(parameter, argument_1)									log "finale_url from scene:::" & final_url								else									log "Scene not fired because not found: " & parameter								end if																# Fire trigger with given name							else if action is "t" then								set final_url to my FireTrigger(parameter)							else if action is "r" then								set final_url to "http://" & c4_url & "/action/reset?mac_address=" & destination_mac_address							end if																												if final_url is not equal to "" then								try									do shell script "curl --silent --max-time 3 " & quoted form of final_url								on error									set error_code to "Can't connect with url: " & final_url								end try																								# Display a message how everything was going (good or bad)								if error_code is not "0" then									log "An error has occurered: " & error_code								else									log "Succesfully sent: " & final_url								end if							end if						end if					end if				end tell							end if			set current_slide to current slide						delay 0.15		end repeat	end tellend tellon getScenes()	set more_scenes to true	set total_scenes to 0		# Get all the scenes of the C4	repeat while more_scenes is true		set get_url to "http://" & c4_url & "/action/scene_manager?subaction=list&length=5&offset=" & total_scenes & "&mac_address=" & destination_mac_address		set scene_response to (do shell script "curl --silent --max-time 3 " & quoted form of get_url)				# Check for any errors in the message		if "\"error\"" is in scene_response then			log "Message from C4: " & scene_response			error number -2		end if				# Get the JSON array where the array of scenes are in		set scene_list_json to ""				tell application "JSON Helper"			set scene_response_json to read JSON from scene_response			set scene_list_json to |list| of scene_response_json		end tell				# Minimum length of the scene response is 90		if length of scene_response < 90 and total_scenes is 0 then			log "INFO: No scenes found"			return		end if				# Split each scene into a seperate string		#set scene_list_array to my theSplit(scene_list_string, "},{")				set new_scenes to 0				# Add from each found scene, the name and unique_id in 2 seperate arrays		repeat with i from 1 to the count of scene_list_json			set scene_item to item i of scene_list_json									set unique_id to filename of scene_item			set scene_name to |name| of scene_item			set unique_id to text 1 thru -5 of unique_id						set unique_id to (do shell script "echo 'ibase=16; " & unique_id & "' | bc")						copy unique_id to the end of the list_unique_id			copy scene_name to the end of the list_scenename						set new_scenes to (new_scenes + 1)						log "Scene " & (i + total_scenes) & " Name: " & scene_name & " and ID: " & unique_id		end repeat				set total_scenes to (total_scenes + new_scenes)				# When the size of the result array is 4 or lower, all scenes are retrieved. Break out of the repeat		if new_scenes is not 5 then			set more_scenes to false		end if			end repeat		log "Total scenes found: " & total_scenesend getSceneson getPlaylists()	set more_playlists to true	set total_playlists to 0		# Get all the playlists of the C4	repeat while more_playlists is true		set get_url to "http://" & c4_url & "/action/scene_manager?subaction=list&type=playlist&length=5&offset=" & total_playlists & "&mac_address=" & destination_mac_address		set playlist_response to (do shell script "curl --silent --max-time 3 " & quoted form of get_url)				# Check for any errors in the message		if "\"error\"" is in playlist_response then			log "Message from C4: " & playlist_response			error number -2		end if				# Get the JSON array where the array of playlists are in		tell application "JSON Helper"			set playlist_response_json to read JSON from playlist_response			set playlist_list_json to |list| of playlist_response_json		end tell				# Minimum length of the playlist response is 90		if length of playlist_response < 90 then			log "INFO: No Playlists found"			return		end if				set new_playlists to 0				# Add from each found playlist, the name and unique_id in 2 seperate arrays		repeat with i from 1 to the count of playlist_list_json			set playlist_item to item i of playlist_list_json						#log "ITEM PLAYLIST: " & playlist_item						set unique_id to filename of playlist_item			set playlist_name to |name| of playlist_item			set unique_id to text 1 thru -5 of unique_id						set unique_id to (do shell script "echo 'ibase=16; " & unique_id & "' | bc")						copy unique_id to the end of the list_playlist_unique_id			copy playlist_name to the end of the list_playlist_name						set new_playlists to (new_playlists + 1)						log "Playlist " & (i + total_playlists) & " Name: " & playlist_name & " and ID: " & unique_id		end repeat				set total_playlists to (total_playlists + new_playlists)				# When the size of the result array is 4 or lower, all playlists are retrieved. Break out of the repeat		if new_playlists is not 5 then			set more_playlists to false		end if			end repeat		log "Total Playlists found: " & total_playlistsend getPlaylistson checkFirmware()	set get_url to "http://" & c4_url & "/action/about?mac_address=" & destination_mac_address	set about_response to (do shell script "curl --silent --max-time 3 " & quoted form of get_url)		if "Applescript" is not in about_response then		log "This C4 Firmware is NOT compatible with Applescript. Please inform Dennis from DiGidot."		error number -99	end ifend checkFirmwareon FireTrigger(triggername)	set trigger_url to "http://" & c4_url & "/action/trigger?subaction=fire&mac_address=" & destination_mac_address & "&name=" & triggername	return trigger_urlend FireTriggeron PlayScene(unique_id, fade)	set scene_url to "http://" & c4_url & "/action/playback?subaction=play&type=scene&fade=1000&mac_address=" & destination_mac_address & "&unique_id=" & unique_id	return scene_urlend PlaySceneon StartPlaylist(playlistname, fade)	set playlist_url to "http://" & c4_url & "/action/playback?subaction=play&type=playlist&fade=" & fade & "&mac_address=" & destination_mac_address & "&unique_id=" & playlistname	return playlist_urlend StartPlaylist# Helper function to split an line of text into a array with a delimiteron theSplit(theString, theDelimiter)	-- save delimiters to restore old settings	set oldDelimiters to AppleScript's text item delimiters	-- set delimiters to delimiter to be used	set AppleScript's text item delimiters to theDelimiter	-- create the array	set theArray to every text item of theString	-- restore the old setting	set AppleScript's text item delimiters to oldDelimiters	-- return the result	return theArrayend theSpliton readFile(theFile)	-- Convert the file to a string	set theFile to theFile as string		-- Read the file and return its contents	return read file theFileend readFileon substring(str, substring_1, offset_1, substring_2, offset_2)	return text ((offset of substring_1 in str) + offset_1) thru ((offset of substring_2 in str) + offset_2) of strend substringon list_position(this_item, this_list)	repeat with i from 1 to the count of this_list		if item i of this_list is this_item then return i	end repeat	return -1end list_position